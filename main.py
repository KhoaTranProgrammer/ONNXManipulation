import sys
import onnx
import argparse
import numpy as np
from ONMAOperators import ONMAOperators

global args

operator_list = \
{
    "Abs": {"function": "ONMAOperator_1_Input_1_Output", "arguments": { "graph_name": "Abs_sample"}},
    "Acos": {"function": "ONMAOperator_1_Input_1_Output", "arguments": { "graph_name": "Acos_sample"}},
    "Acosh": {"function": "ONMAOperator_1_Input_1_Output", "arguments": { "graph_name": "Acosh_sample"}},
    "Add": {"function": "ONMAOperator_2_Inputs_1_Output", "arguments": { "graph_name": "Add_sample", "inputs": ["X1", "X2"], "outputs": ["Y"]}},
    "AffineGrid": { },
    "And": {"function": "ONMAOperator_2_Inputs_1_Output", "arguments": { "graph_name": "And_sample", "inputs": ["X1", "X2"], "outputs": ["Y"]}},
    "ArgMax": { },
    "ArgMin": { },
    "Asin": {"function": "ONMAOperator_1_Input_1_Output", "arguments": { "graph_name": "Asin_sample"}},
    "Asinh": {"function": "ONMAOperator_1_Input_1_Output", "arguments": { "graph_name": "Asinh_sample"}},
    "Atan": {"function": "ONMAOperator_1_Input_1_Output", "arguments": { "graph_name": "Atan_sample"}},
    "Atanh": {"function": "ONMAOperator_1_Input_1_Output", "arguments": { "graph_name": "Atanh_sample"}},
    "AveragePool": { },
    "BatchNormalization": { },
    "Bernoulli": { },
    "BitShift": {"function": "ONMAOperator_2_Inputs_1_Output", "arguments": { "graph_name": "BitShift_sample", "direction": "LEFT"}},
    "BitwiseAnd": {"function": "ONMAOperator_2_Inputs_1_Output", "arguments": { "graph_name": "BitwiseAnd_sample"}},
    "BitwiseNot": {"function": "ONMAOperator_1_Input_1_Output", "arguments": { "graph_name": "BitwiseNot_sample"}},
    "BitwiseOr": {"function": "ONMAOperator_2_Inputs_1_Output", "arguments": { "graph_name": "BitwiseOr_sample"}},
    "BitwiseXor": {"function": "ONMAOperator_2_Inputs_1_Output", "arguments": { "graph_name": "BitwiseXor_sample"}},
    "BlackmanWindow": { },
    "Cast": { },
    "CastLike": { },
    "Ceil": {"function": "ONMAOperator_1_Input_1_Output", "arguments": { "graph_name": "Ceil_sample"}},
    "Celu": {"function": "ONMAOperator_1_Input_1_Output", "arguments": { "graph_name": "Celu_sample", "alpha": 2.0}},
    "CenterCropPad": {"function": "ONMAOperator_2_Inputs_1_Output", "arguments": { "graph_name": "CenterCropPad_sample", "axes": [-3, -2]}},
    "Clip": {"function": "ONMAOperator_3_Inputs_1_Output", "arguments": { "graph_name": "Clip_sample"}},
    "Col2Im": {"function": "ONMAOperator_3_Inputs_1_Output", "arguments": { "graph_name": "Col2Im_sample"}},
    "Compress": {"function": "ONMAOperator_2_Inputs_1_Output", "arguments": { "graph_name": "Compress_sample", "axis": 0}},
    "Concat": { },
    "ConcatFromSequence": { },
    "Constant": { },
    "ConstantOfShape": { },
    "Conv": { },
    "ConvInteger": { },
    "ConvTranspose": { },
    "Cos": { },
    "Cosh": { },
    "CumSum": { },
    "DFT": { },
    "DeformConv": { },
    "DepthToSpace": { },
    "DequantizeLinear": { },
    "Det": { },
    "Div": { },
    "Dropout": { },
    "DynamicQuantizeLinear": { },
    "Einsum": { },
    "Elu": { },
    "Equal": { },
    "Erf": { },
    "Exp": { },
    "Expand": { },
    "EyeLike": { },
    "Flatten": { },
    "Floor": { },
    "GRU": { },
    "Gather": { },
    "GatherElements": { },
    "GatherND": { },
    "Gelu": { },
    "Gemm": { },
    "GlobalAveragePool": { },
    "GlobalLpPool": { },
    "GlobalMaxPool": { },
    "Greater": { },
    "GreaterOrEqual": { },
    "GridSample": { },
    "GroupNormalization": { },
    "HammingWindow": { },
    "HannWindow": { },
    "HardSigmoid": { },
    "HardSwish": { },
    "Hardmax": { },
    "Identity": { },
    "If": { },
    "ImageDecoder": { },
    "InstanceNormalization": { },
    "IsInf": { },
    "IsNaN": { },
    "LRN": { },
    "LSTM": { },
    "LayerNormalization": { },
    "LeakyRelu": { },
    "Less": { },
    "LessOrEqual": { },
    "Log": { },
    "LogSoftmax": { },
    "Loop": { },
    "LpNormalization": { },
    "LpPool": { },
    "MatMul": { },
    "MatMulInteger": { },
    "Max": { },
    "MaxPool": { },
    "MaxRoiPool": { },
    "MaxUnpool": { },
    "Mean": { },
    "MeanVarianceNormalization": { },
    "MelWeightMatrix": { },
    "Min": { },
    "Mish": { },
    "Mod": { },
    "Mul": { },
    "Multinomial": { },
    "Neg": { },
    "NegativeLogLikelihoodLoss": { },
    "NonMaxSuppression": { },
    "NonZero": { },
    "Not": { },
    "OneHot": { },
    "Optional": { },
    "OptionalGetElement": { },
    "OptionalHasElement": { },
    "Or": { },
    "PRelu": { },
    "Pad": { },
    "Pow": { },
    "QLinearConv": { },
    "QLinearMatMul": { },
    "QuantizeLinear": { },
    "RNN": { },
    "RandomNormal": { },
    "RandomNormalLike": { },
    "RandomUniform": { },
    "RandomUniformLike": { },
    "Range": { },
    "Reciprocal": { },
    "ReduceL1": { },
    "ReduceL2": { },
    "ReduceLogSum": { },
    "ReduceLogSumExp": { },
    "ReduceMax": { },
    "ReduceMean": { },
    "ReduceMin": { },
    "ReduceProd": { },
    "ReduceSum": { },
    "ReduceSumSquare": { },
    "RegexFullMatch": { },
    "Relu": { },
    "Reshape": { },
    "Resize": { },
    "ReverseSequence": { },
    "RoiAlign": { },
    "Round": { },
    "STFT": { },
    "Scan": { },
    "Scatter": { },
    "ScatterElements": { },
    "ScatterND": { },
    "Selu": { },
    "SequenceAt": { },
    "SequenceConstruct": { },
    "SequenceEmpty": { },
    "SequenceErase": { },
    "SequenceInsert": { },
    "SequenceLength": { },
    "SequenceMap": { },
    "Shape": { },
    "Shrink": { },
    "Sigmoid": { },
    "Sign": { },
    "Sin": { },
    "Sinh": { },
    "Size": { },
    "Slice": { },
    "Softmax": { },
    "SoftmaxCrossEntropyLoss": { },
    "Softplus": { },
    "Softsign": { },
    "SpaceToDepth": { },
    "Split": { },
    "SplitToSequence": { },
    "Sqrt": { },
    "Squeeze": { },
    "StringConcat": { },
    "StringNormalizer": { },
    "StringSplit": { },
    "Sub": { },
    "Sum": { },
    "Tan": { },
    "Tanh": { },
    "TfIdfVectorizer": { },
    "ThresholdedRelu": { },
    "Tile": { },
    "TopK": { },
    "Transpose": { },
    "Trilu": { },
    "Unique": { },
    "Unsqueeze": { },
    "Upsample": { },
    "Where": { },
    "Xor": { },
}

def main():
    global args

    parser = argparse.ArgumentParser()
    parser.add_argument("--operator", "-op", help="Operator name", default="")
    args = parser.parse_args()

    function_name = operator_list[args.operator]["function"]
    operator_processing = getattr(ONMAOperators, function_name)
    operator_processing(args.operator, **operator_list[args.operator]["arguments"])

if main() == False:
    sys.exit(-1)
